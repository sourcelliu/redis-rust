// Configuration file parser
// Parses Redis-style configuration files

use std::collections::HashMap;
use anyhow::{Result, bail};
use super::static_config::ConfigValue;

pub struct ConfigParser {
    content: String,
}

impl ConfigParser {
    pub fn new(content: &str) -> Self {
        Self {
            content: content.to_string(),
        }
    }

    /// Parse the configuration file content
    pub fn parse(&self) -> Result<HashMap<String, ConfigValue>> {
        let mut config = HashMap::new();

        for (line_num, line) in self.content.lines().enumerate() {
            let line = line.trim();

            // Skip empty lines and comments
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            // Parse the line
            if let Some((key, value)) = self.parse_line(line) {
                config.insert(key, value);
            } else {
                // Log warning but don't fail
                eprintln!("Warning: Invalid configuration at line {}: {}", line_num + 1, line);
            }
        }

        Ok(config)
    }

    /// Parse a single configuration line
    fn parse_line(&self, line: &str) -> Option<(String, ConfigValue)> {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.is_empty() {
            return None;
        }

        let key = parts[0].to_lowercase();

        if parts.len() == 1 {
            // Boolean flag (like "daemonize")
            return None; // These typically need a value
        }

        let value_parts = &parts[1..];

        // Handle different configuration types
        let value = if value_parts.len() == 1 {
            // Single value
            self.parse_single_value(&key, value_parts[0])
        } else {
            // Multiple values (list)
            ConfigValue::List(value_parts.iter().map(|s| s.to_string()).collect())
        };

        Some((key, value))
    }

    /// Parse a single value based on the key
    fn parse_single_value(&self, key: &str, value: &str) -> ConfigValue {
        // Boolean values
        if matches!(value.to_lowercase().as_str(), "yes" | "no" | "true" | "false") {
            let bool_val = matches!(value.to_lowercase().as_str(), "yes" | "true");
            return ConfigValue::Bool(bool_val);
        }

        // Try to parse as integer
        if let Ok(int_val) = value.parse::<i64>() {
            return ConfigValue::Int(int_val);
        }

        // Try to parse as float
        if let Ok(float_val) = value.parse::<f64>() {
            return ConfigValue::Float(float_val);
        }

        // Default to string
        // Remove quotes if present
        let string_val = value.trim_matches('"').trim_matches('\'').to_string();
        ConfigValue::String(string_val)
    }
}

/// Helper function to format configuration for writing to file
pub fn format_config(config: &HashMap<String, String>) -> String {
    let mut lines = Vec::new();

    // Add header
    lines.push("# Redis configuration file".to_string());
    lines.push("# Generated by redis-rust".to_string());
    lines.push("".to_string());

    // Group configurations by category
    let categories = vec![
        ("Network", vec!["bind", "port", "tcp-backlog", "timeout", "tcp-keepalive"]),
        ("General", vec!["daemonize", "databases", "loglevel", "logfile"]),
        ("Snapshotting", vec!["save", "stop-writes-on-bgsave-error", "rdbcompression",
                              "rdbchecksum", "dbfilename", "dir"]),
        ("Replication", vec!["replicaof", "masterauth", "replica-serve-stale-data",
                            "replica-read-only", "repl-diskless-sync"]),
        ("Security", vec!["requirepass", "aclfile"]),
        ("Limits", vec!["maxclients", "maxmemory", "maxmemory-policy"]),
        ("Append Only Mode", vec!["appendonly", "appendfilename", "appendfsync",
                                 "no-appendfsync-on-rewrite", "auto-aof-rewrite-percentage"]),
        ("Slow Log", vec!["slowlog-log-slower-than", "slowlog-max-len"]),
        ("Cluster", vec!["cluster-enabled", "cluster-config-file", "cluster-node-timeout"]),
    ];

    for (category, keys) in &categories {
        lines.push(format!("################################## {} ##################################", category));
        lines.push("".to_string());

        for key in keys {
            if let Some(value) = config.get(*key) {
                lines.push(format!("{} {}", key, value));
            }
        }
        lines.push("".to_string());
    }

    // Add any remaining keys not in categories
    for (key, value) in config.iter() {
        if !categories.iter().any(|(_, keys)| keys.contains(&key.as_str())) {
            lines.push(format!("{} {}", key, value));
        }
    }

    lines.join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_config() {
        let content = r#"
            port 6379
            bind 127.0.0.1
            databases 16
            appendonly yes
        "#;

        let parser = ConfigParser::new(content);
        let config = parser.parse().unwrap();

        assert_eq!(config.get("port"), Some(&ConfigValue::Int(6379)));
        assert_eq!(config.get("bind"), Some(&ConfigValue::String("127.0.0.1".to_string())));
        assert_eq!(config.get("databases"), Some(&ConfigValue::Int(16)));
        assert_eq!(config.get("appendonly"), Some(&ConfigValue::Bool(true)));
    }

    #[test]
    fn test_parse_with_comments() {
        let content = r#"
            # This is a comment
            port 6379
            # Another comment
            databases 16
        "#;

        let parser = ConfigParser::new(content);
        let config = parser.parse().unwrap();

        assert_eq!(config.get("port"), Some(&ConfigValue::Int(6379)));
        assert_eq!(config.get("databases"), Some(&ConfigValue::Int(16)));
    }

    #[test]
    fn test_parse_list_values() {
        let content = "save 900 1 300 10 60 10000";

        let parser = ConfigParser::new(content);
        let config = parser.parse().unwrap();

        if let Some(ConfigValue::List(values)) = config.get("save") {
            assert_eq!(values.len(), 6);
            assert_eq!(values[0], "900");
            assert_eq!(values[5], "10000");
        } else {
            panic!("Expected list value for 'save'");
        }
    }

    #[test]
    fn test_format_config() {
        let mut config = HashMap::new();
        config.insert("port".to_string(), "6379".to_string());
        config.insert("bind".to_string(), "127.0.0.1".to_string());
        config.insert("databases".to_string(), "16".to_string());

        let formatted = format_config(&config);
        assert!(formatted.contains("port 6379"));
        assert!(formatted.contains("bind 127.0.0.1"));
        assert!(formatted.contains("databases 16"));
    }
}
